
include:
  - local: .gitlab/stage_build_base.yml
  - local: .gitlab/stage_image_check.yml
  - local: .gitlab/stage_build.yml

stages:
  - ci-infrastructure-check
  - trigger-infrastructure
  - signal
  - clear-docker-cache
  - build-base
  - provision-client
  - image-check
  - build
  - end-to-end-setup-arango
  - end-to-end-setup
  - end-to-end-test

# WARNING
#
# Do not put if else statements without if and else, gitlab yaml does not like
# this kind of scripting
#
# [ -f file_path ] && ok do this....

variables:
  HARBOR_USER: 'robot$$datafed+harbor_datafed_gitlab_ci_registry_2'
  REGISTRY: 'camden.ornl.gov'
  DATAFED_DEPENDENCIES_INSTALL_PATH: "/shared/install"
################################################################################
# STAGE: ci-infrastructure-check
################################################################################
# ci-infrastructure-check stage is designed to check that the infrastructure is
# up and running before attempting to launch the CI pipelines

check-ci-infrastructure:
  stage: ci-infrastructure-check
  tags:
    - datafed-infrastructure
  script:
    - |
      BUILD_INFRASTRUCTURE="FALSE"
      COMPUTE_INSTANCE_NAMES=("ci-datafed-arangodb" "ci-datafed-core" "ci-datafed-globus2" "ci-datafed-client")
      for INSTANCE_NAME in "${COMPUTE_INSTANCE_NAMES[@]}"; do
        if ! ./scripts/ci_pipeline_setup.sh --compute-instance-name "$INSTANCE_NAME"; then
          BUILD_INFRASTRUCTURE="TRUE"
        fi
      done
      if [ "$BUILD_INFRASTRUCTURE" == "TRUE" ]
      then
        cp .gitlab/build_ci_infrastructure.yml ci_infrastructure.yml
      else
        cp .gitlab/skip_ci_infrastructure.yml ci_infrastructure.yml
      fi
  resource_group: infrastructure_build
  artifacts:
    paths:
      - ci_infrastructure.yml 

run-trigger-job:
  stage: trigger-infrastructure
  trigger:
    include:
      - artifact: ci_infrastructure.yml
        job: check-ci-infrastructure
    strategy: depend
  resource_group: infrastructure_build

################################################################################
# STAGE: signal
################################################################################
# Stage is used to separte the trigger job from the remaining jobs and to act
# as an anchor for setting up dependencies
signal:
  stage: signal
  tags:
    - runner
  script:
    - echo "Starting Build"
  rules:
    - exists:
      - check-ci-infrastrucure
    - exists:
      - run-trigger-job
    - when: on_success

################################################################################
# STAGE: clear-docker-cache
################################################################################
# Used to clear out the cache on VMs where the images are being built
clear-core-cache:
  stage: clear-docker-cache
  needs: ["signal"]
  tags:
    - ci_1
  script:
    - docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
    - docker system prune -f
    - ./scripts/ci_purge_images.sh

clear-repo-cache:
  stage: clear-docker-cache
  needs: ["signal"]
  tags:
    - ci_3
  script:
    - docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
    - docker system prune -f
    - ./scripts/ci_purge_images.sh

clear-python-client-cache:
  stage: clear-docker-cache
  variables:
    DATAFED_CI_PURGE_THRESHOLD: "10"
  needs: ["signal"]
  tags:
    - ci_5
  script:
    - docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
    - docker system prune -f
    - ./scripts/ci_purge_images.sh

################################################################################
# STAGE: build-base
################################################################################
# build runtime and depedencies containers
#include:
#  - local: .gitlab/stage_build_base.yml
    #build-dependencies:
    #  stage: build-base
    #  variables:
    #    IMAGE_TAG: "datafed/dependencies"
    #    GIT_STRATEGY: clone
    #  tags:
    #    - docker
    #  script:
    #    - BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
    #    - docker system prune -f
    #    - docker build -f docker/Dockerfile.dependencies -t "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest" .
    #    - docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
    #    - docker push "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest"
    #
    #build-runtime:
    #  stage: build-base
    #  variables:
    #    IMAGE_TAG: "datafed/runtime"
    #    GIT_STRATEGY: clone
    #  tags:
    #    - docker
    #  script:
    #    - BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
    #    - docker system prune -f
    #    - docker build -f docker/Dockerfile.runtime -t "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest" .
    #    - docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
    #    - docker push "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest"

#################################################################################
## STAGE: provision client
#################################################################################
provision-client:
  needs: ["signal"]
  variables:
    GIT_STRATEGY: clone
  stage: provision-client
  tags:
    - ci-datafed-client
  before_script:
    - export PATH=/opt/datafed/dependencies/bin:$PATH
  script:
    - ./scripts/generate_datafed.sh
    - ./scripts/install_client_dependencies.sh
      #  rules:
      #    - changes:
      #        - scripts/generate_datafed.sh
      #        - scripts/install_client_dependencies.sh
      #        - scripts/dependency_install_functions.sh
      #        - scripts/dependency_versions.sh

################################################################################
# STAGE: image-check
################################################################################
# This stage is needed to determine if the images exist in the registry and 
# if they don't always be sure to build the image.
#
#check-ws-image:
#  stage: image-check
#  variables:
#    IMAGE_TAG: "datafed/ws"
#  tags:
#    - docker
#  script:
#    - |
#      BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
#      docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
#      FORCE_BUILD_WS="FALSE"
#      set +e
#      docker pull --quiet "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest"
#      if [ $? -eq 0 ]; then echo "Image exists"; else FORCE_BUILD_WS="TRUE"; fi;
#      set -e
#      if [ "$FORCE_BUILD_WS" == "TRUE" ]
#      then
#        cp .gitlab/force_build_ws_image.yml ws_image.yml
#      else
#        cp .gitlab/build_ws_image.yml ws_image.yml
#      fi
#      echo "REGISTRY=${REGISTRY}" >> build.env
#      echo "HARBOR_USER=${HARBOR_USER}" >> build.env
#      echo "HARBOR_DATAFED_GITLAB_CI_REGISTRY=${HARBOR_DATAFED_GITLAB_CI_REGISTRY}" >> build.env
#      sed -i 's/\(HARBOR_USER=.*\)\$/\1$$/g' build.env
#  artifacts:
#    paths:
#      - ws_image.yml 
#    reports:
#      dotenv: build.env

      #check-core-image:
      #  stage: image-check
      #  variables:
      #    IMAGE_TAG: "datafed/core"
      #  tags:
      #    - docker
      #  script:
      #    - |
      #      BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
      #      docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
      #      FORCE_BUILD_CORE="FALSE"
      #      set +e
      #      docker pull --quiet "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest"
      #      if [ $? -eq 0 ]; then echo "Image exists"; else FORCE_BUILD_CORE="TRUE"; fi;
      #      set -e
      #      if [ "$FORCE_BUILD_CORE" == "TRUE" ]
      #      then
      #        cp .gitlab/force_build_core_image.yml core_image.yml
      #      else
      #        cp .gitlab/build_core_image.yml core_image.yml
      #      fi
      #      echo "REGISTRY=${REGISTRY}" >> build.env
      #      echo "HARBOR_USER=${HARBOR_USER}" >> build.env
      #      echo "HARBOR_DATAFED_GITLAB_CI_REGISTRY=${HARBOR_DATAFED_GITLAB_CI_REGISTRY}" >> build.env
      #      sed -i 's/\(HARBOR_USER=.*\)\$/\1$$/g' build.env
      #  artifacts:
      #    paths:
      #      - core_image.yml 
      #    reports:
      #      dotenv: build.env

        #check-repo-image:
        #  stage: image-check
        #  variables:
        #    IMAGE_TAG: "datafed/repo"
        #  tags:
        #    - docker
        #  script:
        #    - |
        #      BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
        #      docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
        #      FORCE_BUILD_REPO="FALSE"
        #      set +e
        #      docker pull --quiet "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest"
        #      if [ $? -eq 0 ]; then echo "Image exists"; else FORCE_BUILD_REPO="TRUE"; fi;
        #      set -e
        #      if [ "$FORCE_BUILD_REPO" == "TRUE" ]
        #      then
        #        cp .gitlab/force_build_repo_image.yml repo_image.yml
        #      else
        #        cp .gitlab/build_repo_image.yml repo_image.yml
        #      fi
        #      echo "REGISTRY=${REGISTRY}" >> build.env
        #      echo "HARBOR_USER=${HARBOR_USER}" >> build.env
        #      echo "HARBOR_DATAFED_GITLAB_CI_REGISTRY=${HARBOR_DATAFED_GITLAB_CI_REGISTRY}" >> build.env
        #      sed -i 's/\(HARBOR_USER=.*\)\$/\1$$/g' build.env
        #  artifacts:
        #    paths:
        #      - repo_image.yml 
        #    reports:
        #      dotenv: build.env

        #check-gcs-base-image:
        #  stage: image-check
        #  variables:
        #    IMAGE_TAG: "datafed/gcs-base"
        #  tags:
        #    - docker
        #  script:
        #    - |
        #      BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
        #      docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
        #      FORCE_BUILD_GCS_BASE="FALSE"
        #      set +e
        #      docker pull --quiet "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest"
        #      if [ $? -eq 0 ]; then echo "Image exists"; else FORCE_BUILD_GCS_BASE="TRUE"; fi;
        #      set -e
        #      if [ "$FORCE_BUILD_GCS_BASE" == "TRUE" ]
        #      then
        #        cp .gitlab/force_build_gcs_base_image.yml gcs_base_image.yml
        #      else
        #        cp .gitlab/build_gcs_base_image.yml gcs_base_image.yml
        #      fi
        #      echo "REGISTRY=${REGISTRY}" >> build.env
        #      echo "HARBOR_USER=${HARBOR_USER}" >> build.env
        #      echo "HARBOR_DATAFED_GITLAB_CI_REGISTRY=${HARBOR_DATAFED_GITLAB_CI_REGISTRY}" >> build.env
        #      echo "DATAFED_GCS_SUBMODULE_VERSION=${DATAFED_GCS_SUBMODULE_VERSION}" >> build.env
        #      sed -i 's/\(HARBOR_USER=.*\)\$/\1$$/g' build.env
        #  artifacts:
        #    paths:
        #      - gcs_base_image.yml 
        #    reports:
        #      dotenv: build.env
        #
        #check-gcs-image:
        #  stage: image-check
        #  variables:
        #    IMAGE_TAG: "datafed/gcs"
        #  tags:
        #    - docker
        #  script:
        #    - |
        #      BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
        #      docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
        #      FORCE_BUILD_GCS="FALSE"
        #      set +e
        #      docker pull --quiet "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest"
        #      if [ $? -eq 0 ]; then echo "Image exists"; else FORCE_BUILD_GCS="TRUE"; fi;
        #      set -e
        #      if [ "$FORCE_BUILD_GCS" == "TRUE" ]
        #      then
        #        cp .gitlab/force_build_gcs_image.yml gcs_image.yml
        #      else
        #        cp .gitlab/build_gcs_image.yml gcs_image.yml
        #      fi
        #      echo "REGISTRY=${REGISTRY}" >> build.env
        #      echo "HARBOR_USER=${HARBOR_USER}" >> build.env
        #      echo "HARBOR_DATAFED_GITLAB_CI_REGISTRY=${HARBOR_DATAFED_GITLAB_CI_REGISTRY}" >> build.env
        #      sed -i 's/\(HARBOR_USER=.*\)\$/\1$$/g' build.env
        #  artifacts:
        #    paths:
        #      - gcs_image.yml 
        #    reports:
        #      dotenv: build.env
        #
        #check-foxx-image:
        #  stage: image-check
        #  variables:
        #    IMAGE_TAG: "datafed/foxx"
        #  tags:
        #    - docker
        #  script:
        #    - |
        #      BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
        #      docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
        #      FORCE_BUILD_FOXX="FALSE"
        #      set +e
        #      docker pull --quiet "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest"
        #      if [ $? -eq 0 ]; then echo "Image exists"; else FORCE_BUILD_FOXX="TRUE"; fi;
        #      set -e
        #      if [ "$FORCE_BUILD_FOXX" == "TRUE" ]
        #      then
        #        cp .gitlab/force_build_foxx_image.yml foxx_image.yml
        #      else
        #        cp .gitlab/build_foxx_image.yml foxx_image.yml
        #      fi
        #      echo "REGISTRY=${REGISTRY}" >> build.env
        #      echo "HARBOR_USER=${HARBOR_USER}" >> build.env
        #      echo "HARBOR_DATAFED_GITLAB_CI_REGISTRY=${HARBOR_DATAFED_GITLAB_CI_REGISTRY}" >> build.env
        #      sed -i 's/\(HARBOR_USER=.*\)\$/\1$$/g' build.env
        #  artifacts:
        #    paths:
        #      - foxx_image.yml 
        #    reports:
        #      dotenv: build.env

        #build-python-client-base:
        #  needs: ["clear-python-client-cache"]
        #  variables:
        #    IMAGE_TAG: "datafed/python-client-base"
        #    GIT_STRATEGY: clone
        #  stage: build
        #  tags:
        #    - docker
        #    - ci-datafed-client
        #  script:
        #    - BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
        #    - docker system prune -f
        #    - docker build -f python/docker/Dockerfile.python-client-base.ubuntu -t "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest" .
        #    - docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
        #    - docker push "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest"
        #
        #
        ## Build foxx

################################################################################
# STAGE: build
################################################################################
# Building containers for running services
#include:
#  - local: .gitlab/stage_build.yml
#include:
#run-ws-build-job:
#  needs:
#    - job: build-dependencies
#    - job: build-runtime
#    - job: check-ws-image
#      artifacts: true
#  stage: build
#  trigger:
#    include:
#      - artifact: ws_image.yml
#        job: check-ws-image
#    strategy: depend
#  variables:
#    REGISTRY: "${REGISTRY}"
#    HARBOR_USER: "${HARBOR_USER}"
#    HARBOR_DATAFED_GITLAB_CI_REGISTRY: "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"

    #run-core-build-job:
    #  needs:
    #    - job: build-dependencies
    #    - job: build-runtime
    #    - job: check-core-image
    #      artifacts: true
    #  stage: build
    #  trigger:
    #    include:
    #      - artifact: core_image.yml
    #        job: check-core-image
    #    strategy: depend
    #  variables:
    #    REGISTRY: "${REGISTRY}"
    #    HARBOR_USER: "${HARBOR_USER}"
    #    HARBOR_DATAFED_GITLAB_CI_REGISTRY: "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"

#run-repo-build-job:
#  needs:
#    - job: build-dependencies
#    - job: build-runtime
#    - job: check-repo-image
#      artifacts: true
#  stage: build
#  trigger:
#    include:
#      - artifact: repo_image.yml
#        job: check-repo-image
#    strategy: depend
#  variables:
#    REGISTRY: "${REGISTRY}"
#    HARBOR_USER: "${HARBOR_USER}"
#    HARBOR_DATAFED_GITLAB_CI_REGISTRY: "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
#
#run-gcs-base-build-job:
#  needs:
#    - job: build-dependencies
#    - job: build-runtime
#    - job: check-gcs-base-image
#      artifacts: true
#  stage: build
#  trigger:
#    include:
#      - artifact: gcs_base_image.yml
#        job: check-gcs-base-image
#    strategy: depend
#  variables:
#    REGISTRY: "${REGISTRY}"
#    HARBOR_USER: "${HARBOR_USER}"
#    HARBOR_DATAFED_GITLAB_CI_REGISTRY: "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
#    DATAFED_GCS_SUBMODULE_VERSION: "${DATAFED_GCS_SUBMODULE_VERSION}"
#
#run-gcs-build-job:
#  needs:
#    - job: build-dependencies
#    - job: build-runtime
#    - job: run-gcs-base-build-job
#    - job: check-gcs-image
#      artifacts: true
#  stage: build
#  trigger:
#    include:
#      - artifact: gcs_image.yml
#        job: check-gcs-image
#    strategy: depend
#  variables:
#    REGISTRY: "${REGISTRY}"
#    HARBOR_USER: "${HARBOR_USER}"
#    HARBOR_DATAFED_GITLAB_CI_REGISTRY: "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
#
#run-foxx-build-job:
#  needs:
#    - job: build-dependencies
#    - job: build-runtime
#    - job: check-foxx-image
#      artifacts: true
#  stage: build
#  trigger:
#    include:
#      - artifact: foxx_image.yml
#        job: check-foxx-image
#    strategy: depend
#  variables:
#    REGISTRY: "${REGISTRY}"
#    HARBOR_USER: "${HARBOR_USER}"
#    HARBOR_DATAFED_GITLAB_CI_REGISTRY: "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"



      #build-python-client-base:
      #  needs: ["clear-python-client-cache"]
      #  variables:
      #    IMAGE_TAG: "datafed/python-client-base"
      #    GIT_STRATEGY: clone
      #  stage: build
      #  tags:
      #    - docker
      #    - ci-datafed-client
      #  script:
      #    - BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
      #    - docker system prune -f
      #    - docker build -f python/docker/Dockerfile.python-client-base.ubuntu -t "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest" .
      #    - docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
      #    - docker push "${REGISTRY}/${IMAGE_TAG}-${BRANCH_LOWER}:latest"

################################################################################
# STAGE: End to end setup arango
################################################################################

end-to-end-arango-setup:
  variables:
    GIT_STRATEGY: clone
  stage: end-to-end-setup-arango
  tags:
    - ci-datafed-arango
  script:
    - arangod --version
    - ./scripts/run_arango_service.sh

end-to-end-foxx-setup:
  variables:
    IMAGE_TAG: "datafed/foxx-"
    GIT_STRATEGY: clone
    HOST_LOG_FILE_PATH: "/shared/logs"
    CONTAINER_LOG_FILE_PATH: "/datafed/logs"
    DATAFED_DATABASE_HOST: "$CI_DATAFED_DATABASE_HOST"
    RUN_FILE: "run_foxx.sh"
  stage: end-to-end-setup-arango
  needs: ["end-to-end-arango-setup"]
  tags:
    - docker
  script:
    - sudo apt-get install jq -y
    - BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
    - mkdir -p "$HOST_LOG_FILE_PATH"
    - chmod o+w "${HOST_LOG_FILE_PATH}"
    - USER_ID=$(id -u)
    - chown gitlab-runner "$HOST_LOG_FILE_PATH"
    - echo "$BRANCH_LOWER"
    - ./scripts/generate_datafed.sh
    - env > env_file
    - mkdir foxx_tmp
    - ls -la foxx_tmp
    - if [ -f foxx_tmp/.foxx_is_installed ]; then rm foxx_tmp/.foxx_is_installed; fi
    - docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
    - ./scripts/container_stop.sh -n "foxx-" -p
    - random_string=$(bash -c "cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w "10" | head -n 1")
    - echo "#!/bin/bash" > "${RUN_FILE}"
    - echo "docker run -d \\" >> "${RUN_FILE}"
    - echo "--name \"foxx-${BRANCH_LOWER}-${CI_COMMIT_SHORT_SHA}-${random_string}\" \\" >> "${RUN_FILE}"
    - echo "-e DATAFED_ZEROMQ_SYSTEM_SECRET=\"$CI_DATAFED_ZEROMQ_SYSTEM_SECRET\" \\" >> "${RUN_FILE}"
    - echo "-e DATAFED_DOMAIN=\"$CI_DATAFED_DOMAIN\" \\" >> "${RUN_FILE}"
    - echo "-e DATAFED_DATABASE_PASSWORD=\"$CI_DATAFED_DATABASE_PASSWORD\" \\" >> "${RUN_FILE}"
    - echo "-e DATAFED_DATABASE_IP_ADDRESS_PORT=\"$CI_DATAFED_DATABASE_IP_ADDRESS_PORT\" \\" >> "${RUN_FILE}"
    - echo "-e DATAFED_DATABASE_HOST=\"$CI_DATAFED_DATABASE_HOST\" \\" >> "${RUN_FILE}"
    - echo "-e DATAFED_DEFAULT_LOG_PATH=\"$CONTAINER_LOG_FILE_PATH\" \\" >> "${RUN_FILE}"
    - echo "-e UID=\"$USER_ID\" \\" >> "${RUN_FILE}"
    - echo "-v \"${HOST_LOG_FILE_PATH}:${CONTAINER_LOG_FILE_PATH}\" \\" >> "${RUN_FILE}"
    - echo "-v \"./foxx_tmp:/tmp\" \\" >> "${RUN_FILE}"
    - echo "-t \"${REGISTRY}/${IMAGE_TAG}${BRANCH_LOWER}:latest\"" >> "${RUN_FILE}"
    - chmod +x "${RUN_FILE}"
    - "./${RUN_FILE}"
    - sleep 10
      # Make sure container is running immediately after because it is meant to
      # be ephermal anyway, this is not the same for the other containers
    - ./scripts/container_run_test.sh -e -c "1" -t "${REGISTRY}/${IMAGE_TAG}${BRANCH_LOWER}:latest"
    - while [ ! -f "foxx_tmp/.foxx_is_installed" ]; do echo "Waiting for foxx_tmp/.foxx_is_installed"; sleep 10; done
    - ./scripts/ci_database_health_check.sh
  after_script:
    - rm -rf foxx_tmp

################################################################################
# STAGE: End to end setup
################################################################################

end-to-end-core-setup:
  variables:
    IMAGE_TAG: "datafed/core-"
    GIT_STRATEGY: clone
    HOST_LOG_FILE_PATH: "/shared/logs"
    CONTAINER_LOG_FILE_PATH: "/datafed/logs"
    DATAFED_DATABASE_HOST: "$CI_DATAFED_DATABASE_HOST"
  stage: end-to-end-setup
  needs: ["end-to-end-arango-setup", "end-to-end-foxx-setup"]
  tags:
    - ci-datafed-core
    - docker
  script:
    - BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
    - mkdir -p "$HOST_LOG_FILE_PATH"
    - chmod o+w "${HOST_LOG_FILE_PATH}"
    - USER_ID=$(id -u)
    - chown gitlab-runner "$HOST_LOG_FILE_PATH"
    - echo "$BRANCH_LOWER"
    - ./scripts/generate_datafed.sh
    - env > env_file
    - docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
    - ./scripts/container_stop.sh -n "core-" -p
    - ./scripts/ci_database_health_check.sh
    - cat $CI_DATAFED_CORE_PUB_KEY > /shared/keys/datafed-core-key.pub
    - cat $CI_DATAFED_CORE_PRIV_KEY > /shared/keys/datafed-core-key.priv
    - random_string=$(bash -c "cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w "10" | head -n 1")
    - echo "#!/bin/bash" > run_core.sh
    - echo "docker run -d \\" >> run_core.sh
    - echo "--name \"core-${BRANCH_LOWER}-${CI_COMMIT_SHORT_SHA}-${random_string}\" \\" >> run_core.sh
    - echo "-e DATAFED_GLOBUS_APP_SECRET=\"$CI_DATAFED_GLOBUS_APP_SECRET\" \\" >> run_core.sh
    - echo "-e DATAFED_GLOBUS_APP_ID=\"$CI_DATAFED_GLOBUS_APP_ID\" \\" >> run_core.sh
    - echo "-e DATAFED_ZEROMQ_SESSION_SECRET=\"$CI_DATAFED_ZEROMQ_SESSION_SECRET\" \\" >> run_core.sh
    - echo "-e DATAFED_ZEROMQ_SYSTEM_SECRET=\"$CI_DATAFED_ZEROMQ_SYSTEM_SECRET\" \\" >> run_core.sh
    - echo "-e DATAFED_DOMAIN=\"$CI_DATAFED_DOMAIN\" \\" >> run_core.sh
    - echo "-e DATAFED_DATABASE_PASSWORD=\"$CI_DATAFED_DATABASE_PASSWORD\" \\" >> run_core.sh
    - echo "-e DATAFED_DATABASE_IP_ADDRESS_PORT=\"$CI_DATAFED_DATABASE_IP_ADDRESS_PORT\" \\" >> run_core.sh
    - echo "-e DATAFED_DEFAULT_LOG_PATH=\"$CONTAINER_LOG_FILE_PATH\" \\" >> run_core.sh
    - echo "-e UID=\"$USER_ID\" \\" >> run_core.sh
    - echo "-p 7513:7513 \\" >> run_core.sh
    - echo "-p 7512:7512 \\" >> run_core.sh
    - echo "-v \"${HOST_LOG_FILE_PATH}:${CONTAINER_LOG_FILE_PATH}\" \\" >> run_core.sh
    - echo "-v \"/shared/keys/datafed-core-key.pub\":/opt/datafed/keys/datafed-core-key.pub \\" >> run_core.sh
    - echo "-v \"/shared/keys/datafed-core-key.priv\":/opt/datafed/keys/datafed-core-key.priv \\" >> run_core.sh
    - echo "-t \"${REGISTRY}/${IMAGE_TAG}${BRANCH_LOWER}:latest\"" >> run_core.sh
    - chmod +x run_core.sh
    - ./run_core.sh
    - sleep 10
    - ./scripts/container_run_test.sh -e -c "1" -t "${REGISTRY}/${IMAGE_TAG}${BRANCH_LOWER}:latest" 

end-to-end-ws-setup:
  variables:
    IMAGE_TAG: "datafed/ws-"
    GIT_STRATEGY: clone
    HOST_LOG_FILE_PATH: "/shared/logs"
    CONTAINER_LOG_FILE_PATH: "/datafed/logs"
    DATAFED_WEB_KEY_DIR: "/shared/keys"
    DATAFED_WEB_CERT_NAME: "cert.crt"
    DATAFED_WEB_KEY_NAME: "cert.key"
    DATAFED_WEB_CERT_PATH: "${DATAFED_WEB_KEY_DIR}/${DATAFED_WEB_CERT_NAME}"
    DATAFED_WEB_CSR_PATH: "${DATAFED_WEB_KEY_DIR}/cert.csr"
    DATAFED_WEB_KEY_PATH: "${DATAFED_WEB_KEY_DIR}/${DATAFED_WEB_KEY_NAME}"
  stage: end-to-end-setup
  needs : ["end-to-end-core-setup"]
  tags:
    - ci-datafed-core
    - docker
  script:
    - BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
    - echo "$BRANCH_LOWER"
    - mkdir -p "$HOST_LOG_FILE_PATH"
    - mkdir -p "${DATAFED_WEB_KEY_DIR}"
    - ./scripts/ci_setup_web_certs.sh
    - chmod o+w "${HOST_LOG_FILE_PATH}"
    - chown gitlab-runner "$HOST_LOG_FILE_PATH"
    - ./scripts/generate_datafed.sh
    - docker login  "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
    - USER_ID=$(id -u)
    - GROUP_ID=$(id -g)
    - CORE_ADDRESS=$(hostname -I | awk '{print $1}')
    - cat $CI_DATAFED_CORE_PUB_KEY > /shared/keys/datafed-core-key.pub
    - env
    - ./scripts/container_stop.sh -n "ws-" -p 
    - random_string=$(bash -c "cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w "10" | head -n 1")
    - echo "#!/bin/bash" > run_web.sh
    - echo "docker run -d \\" >> run_web.sh
    - echo "--name \"ws-${BRANCH_LOWER}-${CI_COMMIT_SHORT_SHA}-${random_string}\" \\" >> run_web.sh
    - echo "-e DATAFED_GLOBUS_APP_SECRET=\"$CI_DATAFED_GLOBUS_APP_SECRET\" \\" >> run_web.sh
    - echo "-e DATAFED_GLOBUS_APP_ID=\"$CI_DATAFED_GLOBUS_APP_ID\" \\" >> run_web.sh
    - echo "-e DATAFED_ZEROMQ_SESSION_SECRET=\"$CI_DATAFED_ZEROMQ_SESSION_SECRET\" \\" >> run_web.sh
    - echo "-e DATAFED_ZEROMQ_SYSTEM_SECRET=\"$CI_DATAFED_ZEROMQ_SYSTEM_SECRET\" \\" >> run_web.sh
    - echo "-e DATAFED_DOMAIN=\"$CI_DATAFED_DOMAIN\" \\" >> run_web.sh
    - echo "-e DATAFED_WEB_CERT_PATH=\"/opt/datafed/keys/${DATAFED_WEB_CERT_NAME}\" \\" >> run_web.sh
    - echo "-e DATAFED_WEB_KEY_PATH=\"/opt/datafed/keys/${DATAFED_WEB_KEY_NAME}\" \\" >> run_web.sh
    - echo "-e DATAFED_DEFAULT_LOG_PATH=\"${CONTAINER_LOG_FILE_PATH}\" \\" >> run_web.sh
    - echo "-e DATAFED_CORE_ADDRESS_PORT_INTERNAL=\"$CORE_ADDRESS:7513\" \\" >> run_web.sh
    - echo "-e UID=\"$USER_ID\" \\" >> run_web.sh
    - echo "-p 443:443 \\" >> run_web.sh
    - echo "-v \"${HOST_LOG_FILE_PATH}:${CONTAINER_LOG_FILE_PATH}\" \\" >> run_web.sh
    - echo "-v \"/shared/keys/datafed-core-key.pub:/opt/datafed/keys/datafed-core-key.pub\" \\" >> run_web.sh
    - echo "-v \"${DATAFED_WEB_CERT_PATH}:/opt/datafed/keys/${DATAFED_WEB_CERT_NAME}\" \\" >> run_web.sh
    - echo "-v \"${DATAFED_WEB_KEY_PATH}:/opt/datafed/keys/${DATAFED_WEB_KEY_NAME}\" \\" >> run_web.sh
    - echo "-t \"${REGISTRY}/${IMAGE_TAG}${BRANCH_LOWER}:latest\" " >> run_web.sh
    - chmod +x run_web.sh
    - ./run_web.sh
    - sleep 30
    - ./scripts/container_run_test.sh -e -c "1" -t "${REGISTRY}/${IMAGE_TAG}${BRANCH_LOWER}:latest" 

# Repo server currently will crash on startup if it cannot connect to the core
# server.
end-to-end-repo-setup:
  variables:
    IMAGE_TAG: "datafed/repo-"
    GIT_STRATEGY: clone
    HOST_LOG_FILE_PATH: "/shared/logs"
    CONTAINER_LOG_FILE_PATH: "/datafed/logs"
    DATAFED_HOST_COLLECTION_MOUNT: "/shared/collections"
  stage: end-to-end-setup
  needs: ["end-to-end-ws-setup"]
  tags:
    - ci-datafed-globus
    - docker
  script:
    - BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
    - echo "$BRANCH_LOWER"
    - mkdir -p "$HOST_LOG_FILE_PATH"
    - if [ ! -d "${DATAFED_HOST_COLLECTION_MOUNT}" ]; then mkdir -p "${DATAFED_HOST_COLLECTION_MOUNT}"; fi
    - chmod o+w "${HOST_LOG_FILE_PATH}"
    - USER_ID=$(id -u)
    - chown gitlab-runner "$HOST_LOG_FILE_PATH"
    - ./scripts/generate_datafed.sh
    - docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
    - ./scripts/container_stop.sh -n "repo-" -p
    - random_string=$(bash -c "cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w "10" | head -n 1")
    - cat $CI_DATAFED_CORE_PUB_KEY > /shared/datafed-repo-key.pub
    - cat $CI_DATAFED_CORE_PRIV_KEY > /shared/datafed-repo-key.priv
    - echo "#!/bin/bash" > run_repo.sh
    - echo "docker run -d \\" >> run_repo.sh
    - echo "--name \"repo-${BRANCH_LOWER}-${CI_COMMIT_SHORT_SHA}-${random_string}\" \\" >> run_repo.sh
    - echo "-e DATAFED_GLOBUS_APP_SECRET=\"$CI_DATAFED_GLOBUS_APP_SECRET\" \\" >> run_repo.sh
    - echo "-e DATAFED_GLOBUS_APP_ID=\"$CI_DATAFED_GLOBUS_APP_ID\" \\" >> run_repo.sh
    - echo "-e DATAFED_ZEROMQ_SESSION_SECRET=\"$CI_DATAFED_ZEROMQ_SESSION_SECRET\" \\" >> run_repo.sh
    - echo "-e DATAFED_ZEROMQ_SYSTEM_SECRET=\"$CI_DATAFED_ZEROMQ_SYSTEM_SECRET\" \\" >> run_repo.sh
    - echo "-e DATAFED_HTTPS_SERVER_PORT=\"443\" \\" >> run_repo.sh
    - echo "-e DATAFED_DOMAIN=\"$CI_DATAFED_DOMAIN\" \\" >> run_repo.sh
    - echo "-e DATAFED_CORE_ADDRESS_PORT_INTERNAL=\"${CI_DATAFED_DOMAIN}:7513\" \\" >> run_repo.sh
    - echo "-e DATAFED_DEFAULT_LOG_PATH=\"$CONTAINER_LOG_FILE_PATH\" \\" >> run_repo.sh
    - echo "-e DATAFED_GCS_COLLECTION_ROOT_PATH=\"/mnt/datafed\" \\" >> run_repo.sh
    - echo "-e UID=\"$USER_ID\" \\" >> run_repo.sh
    - echo "-p 9000:9000 \\" >> run_repo.sh
    - echo "-v \"${HOST_LOG_FILE_PATH}:${CONTAINER_LOG_FILE_PATH}\" \\" >> run_repo.sh
    - echo "-v \"${DATAFED_HOST_COLLECTION_MOUNT}:/mnt/datafed\" \\" >> run_repo.sh
    - echo "-v \"/shared/datafed-repo-key.pub\":/opt/datafed/keys/datafed-repo-key.pub \\" >> run_repo.sh
    - echo "-v \"/shared/datafed-repo-key.priv\":/opt/datafed/keys/datafed-repo-key.priv \\" >> run_repo.sh
    - echo "-t \"${REGISTRY}/${IMAGE_TAG}${BRANCH_LOWER}:latest\"" >> run_repo.sh
    - chmod +x run_repo.sh
    - ./run_repo.sh
    - sleep 10
    - ./scripts/container_run_test.sh -e -c "1" -t "${REGISTRY}/${IMAGE_TAG}${BRANCH_LOWER}:latest" 

# Requires setting up Globus Connect Server, requires firewall exceptions on
# the machine running this.
# Note we need the certificates to be available on the gcs-authz container
# if it is meant to be run on the same machine as the metadata services
# because the Apache web server can then route traffic appropriately, if 
# run separate from the metadata services it should not be needed.
# NOTE it should also run after the repo service because when the form is
# generated, it requires the repo server public key.
end-to-end-gcs-authz-setup:
  variables:
    IMAGE_TAG: "datafed/gcs-"
    HOST_LOG_FILE_PATH: "/shared/logs"
    CONTAINER_LOG_FILE_PATH: "/datafed/logs"
    GIT_STRATEGY: clone
    DATAFED_HOST_COLLECTION_MOUNT: "/shared/collections"
    DATAFED_GLOBUS_DIR: "/shared/globus"
  stage: end-to-end-setup
  needs: ["end-to-end-repo-setup"]
  tags:
    - ci-datafed-globus
    - docker
  script:
    - BRANCH_LOWER=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
    - echo "$BRANCH_LOWER"
    - mkdir -p "$HOST_LOG_FILE_PATH"
    - mkdir -p "${DATAFED_GLOBUS_DIR}"
    - cp "${CI_DATAFED_GCS_DEPLOYMENT_KEY}" "${DATAFED_GLOBUS_DIR}/deployment-key.json"
    - cp "${CI_DATAFED_GCS_CLIENT_CRED}" "${DATAFED_GLOBUS_DIR}/client_cred.json"
    - USER_ID=$(id -u)
    - chmod o+w "${HOST_LOG_FILE_PATH}"
    - chown gitlab-runner "$HOST_LOG_FILE_PATH"
    - ./scripts/generate_datafed.sh
    - docker login "${REGISTRY}" -u "${HARBOR_USER}" -p "${HARBOR_DATAFED_GITLAB_CI_REGISTRY}"
    - ./scripts/container_stop.sh -n "gcs-authz" -p
    - random_string=$(bash -c "cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w "10" | head -n 1")
    - cat $CI_DATAFED_CORE_PUB_KEY > /shared/datafed-repo-key.pub
    - cat $CI_DATAFED_CORE_PRIV_KEY > /shared/datafed-repo-key.priv
    - echo "#!/bin/bash" > run_globus.sh
    - echo "docker run -d \\" >> run_globus.sh
    - echo "--name \"gcs-authz-${BRANCH_LOWER}-${CI_COMMIT_SHORT_SHA}-${random_string}\" \\" >> run_globus.sh
    - echo "--network host \\" >> run_globus.sh
    - echo "-e DATAFED_GLOBUS_APP_SECRET=\"$CI_DATAFED_GLOBUS_APP_SECRET\" \\" >> run_globus.sh
    - echo "-e DATAFED_GLOBUS_APP_ID=\"$CI_DATAFED_GLOBUS_APP_ID\" \\" >> run_globus.sh
    - echo "-e DATAFED_ZEROMQ_SESSION_SECRET=\"$CI_DATAFED_ZEROMQ_SESSION_SECRET\" \\" >> run_globus.sh
    - echo "-e DATAFED_ZEROMQ_SYSTEM_SECRET=\"$CI_DATAFED_ZEROMQ_SYSTEM_SECRET\" \\" >> run_globus.sh
    - echo "-e DATAFED_DOMAIN=\"$CI_DATAFED_DOMAIN\" \\" >> run_globus.sh
    - echo "-e DATAFED_HTTPS_SERVER_PORT=\"443\" \\" >> run_globus.sh
    - echo "-e DATAFED_DEFAULT_LOG_PATH=\"$CONTAINER_LOG_FILE_PATH\" \\" >> run_globus.sh
    - echo "-e DATAFED_CORE_ADDRESS_PORT_INTERNAL=\"${CI_DATAFED_DOMAIN}:7513\" \\" >> run_globus.sh
    - echo "-e DATAFED_GCS_ROOT_NAME=\"${CI_DATAFED_GCS_ROOT_NAME}\" \\" >> run_globus.sh
    - echo "-e DATAFED_GCS_COLLECTION_ROOT_PATH=\"/mnt/datafed\" \\" >> run_globus.sh
    - echo "-e DATAFED_GLOBUS_SUBSCRIPTION=\"${CI_DATAFED_GLOBUS_SUBSCRIPTION}\" \\" >> run_globus.sh
    - echo "-e DATAFED_GLOBUS_CONTROL_PORT=\"443\" \\" >> run_globus.sh
    - echo "-e DATAFED_REPO_USER=\"datafed\" \\" >> run_globus.sh
    - echo "-e DATAFED_AUTHZ_USER=\"datafed\" \\" >> run_globus.sh
    - echo "-e UID=\"$USER_ID\" \\" >> run_globus.sh
    - echo "-e BUILD_WITH_METADATA_SERVICES=\"FALSE\" \\" >> run_globus.sh
    - echo "-e DATAFED_REPO_ID_AND_DIR=\"${CI_DATAFED_REPO_ID_AND_DIR}\" \\" >> run_globus.sh
    - echo "-e DATAFED_GCS_IP=\"${CI_DATAFED_GCS_IP}\" \\" >> run_globus.sh
    - echo "-e DATAFED_REPO_DOMAIN=\"${CI_DATAFED_REPO_DOMAIN}\" \\" >> run_globus.sh
    - echo "-v \"${DATAFED_GLOBUS_DIR}:/opt/datafed/globus\" \\" >> run_globus.sh
    - echo "-v \"${HOST_LOG_FILE_PATH}:${CONTAINER_LOG_FILE_PATH}\" \\" >> run_globus.sh
    - echo "-v \"${DATAFED_HOST_COLLECTION_MOUNT}:/mnt/datafed\" \\" >> run_globus.sh
    - echo "-v \"/shared/datafed-repo-key.pub\":/opt/datafed/keys/datafed-repo-key.pub \\" >> run_globus.sh
    - echo "-v \"/shared/datafed-repo-key.priv\":/opt/datafed/keys/datafed-repo-key.priv \\" >> run_globus.sh
    - echo "-t \"${REGISTRY}/${IMAGE_TAG}${BRANCH_LOWER}:latest\"" >> run_globus.sh
    - if [ -f "${DATAFED_GLOBUS_DIR}/${CI_DATAFED_REPO_ID_AND_DIR}-repo-form.sh" ]; then rm "${DATAFED_GLOBUS_DIR}/${CI_DATAFED_REPO_ID_AND_DIR}-repo-form.sh"; fi
    - chmod +x run_globus.sh
    - ./run_globus.sh
    - while [ ! -f "${DATAFED_GLOBUS_DIR}/${CI_DATAFED_REPO_ID_AND_DIR}-repo-form.sh" ]; do echo "Waiting for ${DATAFED_GLOBUS_DIR}/${CI_DATAFED_REPO_ID_AND_DIR}-repo-form.sh"; sleep 10; done
    - cat "${DATAFED_GLOBUS_DIR}/${CI_DATAFED_REPO_ID_AND_DIR}-repo-form.sh"
    - ./scripts/container_run_test.sh -e -c "1" -t "${REGISTRY}/${IMAGE_TAG}${BRANCH_LOWER}:latest"
    - cp ${DATAFED_GLOBUS_DIR}/${CI_DATAFED_REPO_ID_AND_DIR}-repo-form.sh .
    - cp ${DATAFED_GLOBUS_DIR}/${CI_DATAFED_REPO_ID_AND_DIR}-repo-form.json .
  artifacts:
    paths:
      - "${CI_DATAFED_REPO_ID_AND_DIR}-repo-form.sh"
      - "${CI_DATAFED_REPO_ID_AND_DIR}-repo-form.json"


end_to_end_client-test:
  variables:
    GIT_STRATEGY: clone
    DATAFED_DATABASE_HOST: "${CI_DATAFED_DATABASE_HOST}"
    DATAFED_DATABASE_ZEROMQ_SYSTEM_SECRET: "${CI_DATAFED_DATABASE_ZEROMQ_SYSTEM_SECRET}"
    DATAFED_DATABASE_PASSWORD: "${CI_DATAFED_DATABASE_PASSWORD}"
    DATAFED_USER89_PASSWORD: "${CI_DATAFED_USER89_PASSWORD}"
    DATAFED_USER89_GLOBUS_REFRESH_TOKEN: "${CI_DATAFED_USER89_GLOBUS_REFRESH_TOKEN}"
    DATAFED_USER89_GLOBUS_ACCESS_TOKEN: "${CI_DATAFED_USER89_GLOBUS_ACCESS_TOKEN}"
    DATAFED_USER89_GLOBUS_UUID: "${CI_DATAFED_USER89_GLOBUS_UUID}"
    DATAFED_USER99_PASSWORD: "${CI_DATAFED_USER99_PASSWORD}"
    DATAFED_USER99_GLOBUS_REFRESH_TOKEN: "${CI_DATAFED_USER99_GLOBUS_REFRESH_TOKEN}"
    DATAFED_USER99_GLOBUS_ACCESS_TOKEN: "${CI_DATAFED_USER99_GLOBUS_ACCESS_TOKEN}"
    DATAFED_USER99_GLOBUS_UUID: "${CI_DATAFED_USER99_GLOBUS_UUID}"
    DATAFED_ZEROMQ_SYSTEM_SECRET: "${CI_DATAFED_ZEROMQ_SYSTEM_SECRET}"
    DATAFED_DOMAIN: "${CI_DATAFED_DOMAIN}"
    DATAFED_PYTHON_CLIENT_ALLOW_SELF_SIGNED_CERTS: "TRUE"
  stage: end-to-end-test
  dependencies:
    - end-to-end-gcs-authz-setup
  needs: ["end-to-end-gcs-authz-setup"]
  tags:
    - ci-datafed-client
  script:
    - export DATAFED_REPO_FORM_PATH="$(pwd)/${CI_DATAFED_REPO_ID_AND_DIR}-repo-form.json"
    - env > env_file
    - echo "Testing"
    - ./scripts/generate_datafed.sh
    - >
      cmake -S. -B build
      -DENABLE_FOXX_TESTS=OFF
      -DBUILD_CORE_SERVER=OFF
      -DBUILD_COMMON=OFF
      -DBUILD_WEB_SERVER=OFF
      -DBUILD_DOCS=OFF
      -DBUILD_PYTHON_CLIENT=ON
      -DBUILD_TESTS=ON
      -DENABLE_END_TO_END_TESTS=ON
      -DINSTALL_FOXX=OFF
    - cmake --build build
    - cmake --build build --target pydatafed
    - cmake --build build --target test
